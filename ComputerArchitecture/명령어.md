# 명령어
## 구성 요소
- `하나의 명령어` : `연산 코드` + `0개 이상의 오퍼랜드`
    - `연산 코드 필드` : 연산 코드가 담기는 영역
    - `오퍼랜드 필드(Address Field)` : 오퍼랜드가 담기는 영역
        - 많은 경우, `데이터가 저장된 위치`가 명시된다.
            - 즉, `메모리 주소`, `레지스터 이름`
            - 그래서 `주소 필드(Address Field)`라고도 부른다.
    
    2. `오퍼랜드` : 수행할 대상 
        - 수행할 동작에 사용될 `데이터 자체`
        - 수행할 동작에 사용할 `데이터가 저장된 위치`

### 연산 코드 : 수행할 동작  
- 종류 : CPU에 따라 구체적인것은 다르다. (But, 공통적인 대표적 연산 코드 유형은 아래와 같다.)
    1. 데이터 전송
        1. MOVE : `데이터를 옮겨라`
        2. STORE : `데이터를 저장`하라 
        3. LOAD(FETCH) : 데이터를 `메모리에서 CPU로 가져와라`
        4. PUSH : 데이터를 `스택에 저장`하라
        5. POP : `스택 최상단 데이터`를 꺼내라
    2. 산술/논리 연산
        1. ADD/SUBTRACT/MULTIPLY/DIVIDE : `+`/`-`/`*`/`/` 수행
        2. INCREMENT/DECREMENT : 오퍼랜드 `1증가` / `1감소`
        3. AND/OR/NOT : AND / OR / NOT 연산 수행
        4. COMPARE : 비교 연산 수행
    3. 제어 흐름 변경 
        1. JUMP : `특정 주소`로 실행 순서 `이동`
        2. CONDITIONAL JUMP : `조건 부합` 시, `JUMP`
        3. HALT : 프로그램 `실행 멈춤`
        4. CALL : `돌아올 주소를 저장`한 채, `JUMP`
        5. RETURN : CALL 호출 시, `저장했던 주소`로 `복귀`
    4. 입출력 제어
        1. READ(INPUT) : 특정 입출력장치로부터 데이터를 읽어라
        2. WRITE(OUTPUT) : 특정 입출력장치로부터 데이터를 써라
        3. START IO : 입출력 장치를 시작
        4. TEST IO : 입출력 장치의 현재 상태 확인


## 기계어 / 어셈블리어
### 기계어
- CPU가 이해할 수 있는 0과 1로만 표현된 정보
### 어셈블리어
- 기계어를 `단순 번역`한 언어
    - 어셈블리어를 보면, `명령어의 종류`와 `동작`을 `파악`할 수 있다.

## 명령어 사이클
- `CPU`가 `명령어를 처리`하는 과정에서 `각 명령어`들은 `일정한 주기`를 반복하며 실행, 이 실행을 `명령어 사이클`이라 칭함
    - `메모리` 안에는 `프로그램이 저장`, `프로그램`은 `여러 명령어`로 구성
        - `CPU`는 `메모리`에서 `프로그램의 명령어들`을 `인출-실행` 반복하며 `전체 프로그램을 실행`해나감   
### 단계
1. `메모리->CPU`로 명령어 인출 (`인출 사이클`)
    - 만약, 오퍼랜드 필드에 `주소`가 명시 되었다면, `주소`로 한 번 더 `접근`해야 한다. (`간접 사이클`)
2. `CPU`에서 인출한 `명령어 실행` (`실행 사이클`)
    - 실행 사이클 중, `인터럽트`가 발생한 경우 `인터럽트 서비스 루틴`을 실행하기 위한 사이클로 돌입한다. (`인터럽트 사이클`)
- 따라서, 정리하면 아래와 같다.
    1. 인출 <-> 실행 사이클 (기본)
    2. 인출 -> 간접 -> 실행 -> 인출 ... (오퍼랜드에 주소가 명시된 경우)
    3. 인출 -> 실행 -> 인터럽트 -> 인출 ... (실행 중 인터럽트가 발생한 경우)
    - `간접`과 `인터럽트`사이클은 선택적이지만, `인출`과 `실행`은 `필수`다.


            
